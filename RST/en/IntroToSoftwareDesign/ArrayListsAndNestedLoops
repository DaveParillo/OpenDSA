.. This file is part of the OpenDSA eTextbook project. See
.. http://opendsa.org for more details.
.. Copyright (c) 2012-2020 by the OpenDSA Project Contributors, and
.. distributed under an MIT open source license.

.. avmetadata::
   :author: Molly

Interfaces
----------

Sometimes, it can be important to enforce that certain behaviors get implemented
within a class.  When working with a parent class we specify the fields and methods
we expect all of  the parent's child classes to use.  However, what about
situations where a class  needs to implement a method and it is missing? Here, it
is best to use an *interface*.**Interfaces** are like classes but contain only
abstract method signatures and constants, but no Java fields.

For example, say we wanted to ensure that a series of classes had a ``draw`` method.

.. code-block:: java
   public interface Drawable{

       public void draw();

   }

You'll notice a few things here that are different from other Java code we've seen.  For one
thing, instead of saying public ``class`` we see the keyword ``interface`` used.  For another,
our method signature is followed by a ``;``, not curly braces.   The more general syntax for
writing an interface looks like this:

.. code-block:: java
   public interface <Interface Name>{
      //any number of constant values

      //any number of method signatures WITHOUT implementation.
   }

By itself, this code won't do much.  Instead we need to **implement** it with a class.

.. code-block:: java
   public class Rectangle implements Drawable{

   }

Writing a class definition like this can be really helpful.  The above code will
not compile until we implement a method with the signature ``public void draw()``.
We can add any other fields or methods we want, but that ``draw`` method *must* be
implemented.

By itself, this can seem like something of an odd structure in a language.
Couldn't a developer just remember to implement a that one method?  In our example,
probably.  But what if we needed to make many different types of shape class?  Or
we needed to ensure 15 methods were implemented across many classes?  It is in
these situations an interface really shines.

Check Your Understanding: Interfaces
------------------------------------

.. avembed:: Exercises/IntroToSoftwareDesign/Week8Quiz3Summ.html ka
  :long_name: Interfaces


Data Structures and the List Interface
--------------------------------------

Previously, we've worked on saving specific pieces of data to variables.  For
example, if we had one ``Pixel``, we could create a variable and maybe run some
methods to turn that Pixel white.

.. code-block:: java

   Pixel p1 = new Pixel(0,0);
   p1.setRed(255);
   p1.setGreen(255);
   p1.setBlue(255);

However, odds are if we are working with pixels we won't be considering
singular ones, but a whole image's worth.  If we wanted to, we could create a variable to
represent each ``Pixel`` object...

.. code-block:: java
   Pixel p1 = new Pixel(0,0);
   Pixel p2 = new Pixel(1,0);
   Pixel p3 = new Pixel(2,0);
   //And so on...
   Pixel p592 = new Pixel(591, 0);

However, this becomes pretty tedious and inefficient pretty quickly.
Instead, there's another way we can store many values in one variable
using what's called a **data structure**.  A data structure is a
collection of data that is organized (structured) in some way.

One very common format this organization can take is in the form of a list - so common in fact
that there are many data structures that implement a ``List`` interface.  To use the list
interface, there are quite a few methods a class must implement including the following:

.. list-table:: Some List Interface Methods
   :header-rows: 1

   * - Method Name
     - Purpose
   * - ``add(<some value>)``
     - adds an item to the list
   * - ``get(int <some index>)
     - returns the item stored at this index
   * - ``set(int <some index>, <some value>)
     - sets the item at some index to be some value
   * - ``clear()``
     - removes all elements from the list
   * - ``isEmpty()``
     - returns ``true`` if a list doesn't have any values stored in it, otherwise ``false``
   * - ``remove(int <some index>)``
     - removes element at the specified index from the list
   * - ``size()``
     - returns the number of elements in the list
   * - ``contains(<some value>)``
     - returns ``true`` if the parameter value is in the list, otherwise ``false``


ArrayLists
----------

One such data structure that implements the List interface is the **ArrayList**.  Because it
implements ``List``, you know the data structure has access to the methods described above.

Take a few minutes to watch the following video:

.. raw:: html

  <iframe width="560" height="315" src="https://www.youtube.com/embed/XkJD80HmpdI?start=0&end=1156" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

In an ``ArrayList``, data are arranged in a linear or sequential
structure, with one element following another, but are all accessed
through the same variable.
For example, if we had an ArrayList of integers, it might look like this:


.. odsafig:: Images/ArrIdea.png
   :align: center

The large numbers inside the boxes are the elements of the ``ArrayList``. The small numbers
outside the boxes are the **indexes** (or indices) used to identify each location in the
``ArrayList``. Notice that the index of the first element is 0, not 1, as you might have
expected.  It's important to remember that, much like Pixels in a picture, ``ArrayList``
indexing starts at 0 instead of 1.  Forgetting this fact is an easy mistake to make.

Programming with ArrayLists
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Lets try re-creating the image above as an ``ArrayList`` in code.

Adding an Import
""""""""""""""""

Before we can start though, we need to add an import statement to our code:

.. code-block:: java
   import java.util.ArrayList;

Without this, java will not recognize what an ArrayList is.

Declaring and Instantiating an ArrayList
""""""""""""""""""""""""""""""""""""""""

Once we have our import we can proceed to use declare and instantiate an ArrayList just like any other object - or almost:

.. code-block:: java
   ArrayList<Integer> arr = new <Integer> ArrayList();


There is one small difference between this and a normal object declaration we've seen before
though.  This time, after we specify our we're creating an ArrayList, we say
`<Integer>`.  This tells Java that this ArrayList will only store integers.  We'll get into
more of what we can do with this sort of type specification later, but for now, know
that whatever type of data we are storing, we need to specify it in the variable
declaration using ``<>``.  For example, if we were storing ``Jeroo`` objects we'd specify
``<Jeroo>``, or ``<Pixel>`` if we were storing ``Pixel`` objects.

You may also notice we used the word ``Integer`` instead of ``int``.  This has to do with
what are called "primitive types" versus objects.  We'll get more into what the differences
between these two things are later as well.  For now, just know that if you wanted to create an
ArrayList of ``double``s, you'd specify ``<Double>``.  For ``boolean``s, you'd similarly
use ``<Boolean>``.

Adding our Numbers
""""""""""""""""""

An ArrayList, just like anything else in Java, is a class and has a set of methods we can
call.  To add an item to our ArrayList, we could use the ``add`` method the ``List`` interface requires.

.. code-block:: java

   ArrayList<Integer> arr = new ArrayList<Integer>();
   arr.add(-2);

After this code runs, our ``ArrayList`` would look like this:

.. odsafig:: Images/ArrayListAfterOneAdd.png
   :align: center


If we added another value...

.. code-block:: java

   arr.add(8);

our ``ArrayList`` would look like this:

.. odsafig:: Images/ArrayListAfterTwoAdds.png
   :align: center



Accessing our Numbers
"""""""""""""""""""""

Lets assume we've added all 15 numbers as seen in the diagram above to our ArrayList, but
then wanted to access the second number.

To access the second item in our ArrayList, we would run code like this.

.. code-block:: java

   arr.get(1); // gets the second item in our ArrayList (8)

It is important to note that, unlike our MicroWorlds, even though this is the second item
in our ArrayList, it is at index **1**.  The first item of an ArrayList will always be at index
0.

.. admonition:: Indexing

   For any ArrayList of length `n`, the first item will be at index 0, and the last at
   index `n-1`.

Changing Numbers
""""""""""""""""

We can's treat this ``get`` method call just like we would any other ``int`` variable.   For example, running ``arr.get(0) = 5`` would not change the first item stored in the ArrayList from -2 to 5.  Instead, we  use another ArrayList method to change an existing entry's value.

.. code-block:: java

   arr.set(1, 4);


When we call this ``set`` method, we have to specify two things.  First, the index of the
location we want to change.  In our case, we are trying to change the *second* item in our
ArrayList which should be at index **1**.  This first argument will always be a number.

We want to change the value of the second item in the ArrayList to 4, so ``4`` is our second
argument.  If we'd had an ArrayList of Pixel objects and wanted to use the set method, it
may look like this:

.. code-block:: java
   Pixel p = new Pixel(1,0);
   arr.set(1, p);

Keep in mind though that an ArrayList is only as big as the number of items you have added
to it.  So the following code would break:

.. code-block:: java

   Pixel p1 = new Pixel(0,0);
   Pixel p2 = new Pixel(1,0);
   Pixel p3 = new Pixel(2,0);

   ArrayList<Pixel> arr = new ArrayList<Pixel>();
   arr.add(p1);
   arr.add(p2);
   arr.add(p3);
   arr.set(3, p1); // this line would break as there is not index 3 yet.

The code above would compile, but would fail when you tried to run it.  Again, `p1` is
stored at index 0, `p2` at index 1, and `p3` at index 2.  This ArrayList contains 3 items,
but since it ends at index 2, this set would fail.

In short, if you your code fails and you see an ``IndexOutOfBoundsException``, you're trying
to access a location in the ArrayList that doesn't exist.

Check Your Understanding: ArrayLists
-----------------------------------

.. avembed:: Exercises/IntroToSoftwareDesign/Week8Quiz1Summ.html ka
  :long_name: ArrayLists


Nested For Loops
----------------

When iterating over ``Pixel`` objects in class thus far, we've done so like this (assuming we had a ``Picture`` object named ``picture``)

.. code-block:: java

   for (Pixel p: picture.getPixels())
   {
      // do some transformation
   }

However, what if we wanted to change only every other Pixel?  Or every other row or column?
In these situations a counter controlled loop might be better.

Lets assume we know our picture is a rectangle of 100 pixels wide by 200 pixels long and we have an object of ``Picture`` called ``pic``  We could write a for loop like this.


<TODO: DOUBLE CHECK THIS CODE is the method getPixel?>

.. code-block:: java

   int width = 100;
   int length = 200;

   for (int i = 0; i<width; i++)
   {
       Pixel p = pic.getPixel(i, 0);
       p.setRed(0);
       p.setGreen(0);
       p.setBlue(0);
   }

You'll notice this code works through a series of Pixel objects, setting their RGB value to
(0,0,0), or black.  However, this code will only work through the top row of Pixel objects.  It
accesses the Pixel at (0,0), then (1,0) all the way to (99,0).  However we never use that
``length`` variable defined above and we never change the ``y`` coordinate from 0.  To go
through every Pixel object using a counter controlled loop, we need to do something like this:

.. code-block:: java

   int width = 100;
   int length = 200;

   for (int i = 0; i < width; i++)
   {
       for(int j = 0; j < length; j++)
       {
           Pixel p = pic.getPixel(i, j);
           p.setRed(0);
           p.setGreen(0);
           p.setBlue(0);
       }

   }

Much like conditionals, for loops can be *nested*.

Stepping through this code, when the exterior for loop starts, int ``i`` is initialized to 0
and we know 0 is less than 100 so we can start our loop.  Next, int ``j`` is initialized to 0
which is less than 200, so our second loop can start.  With ``i`` at 0, the second for loop
increments j from 0 to 199.  This means we'd access the Pixel at (0, 0), then (0, 1), all the
way to (0, 199).  Then the interior for loop would terminate and the exterior for loop would
set the value of ``i`` to 1.  Then the whole process would repeat, this time accessing the
Pixel at (1, 0), then (1, 1), all the way to (1, 199).


Check Your Understanding: Nested For Loops
------------------------------------------

.. avembed:: Exercises/IntroToSoftwareDesign/Week8Quiz2Summ.html ka
  :long_name: Nested For Loops



Check Your Understanding
------------------------

.. avembed:: Exercises/IntroToSoftwareDesign/Week8ReadingQuizSumm.html ka
  :long_name: Programming Concepts
